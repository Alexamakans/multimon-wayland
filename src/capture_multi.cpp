// src/capture_multi.cpp
#include "capture_multi.hpp" // assumes this declares CapturedOutput{int x,y,width,height; GLuint texture;}
                             // and functions: wlr_multi_capture_init, wlr_multi_next_frame, wlr_multi_shutdown

#include <wayland-client.h>
#include <EGL/egl.h>
#include <EGL/eglext.h>
#include <GL/gl.h>

#include <fcntl.h>
#include <unistd.h>
#include <gbm.h>
#include <xf86drm.h>
#include <drm_fourcc.h>

#include <vector>
#include <stdexcept>
#include <cstring>
#include <cstdio>

// Generated by wayland-scanner
#include "wlr-screencopy-unstable-v1-client-protocol.h"
#include "linux-dmabuf-unstable-v1-client-protocol.h"

// ---- GL/EGL function pointers (loaded at runtime) ----
static PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES_ = nullptr;
static PFNEGLCREATEIMAGEKHRPROC   p_eglCreateImageKHR   = nullptr;
static PFNEGLDESTROYIMAGEKHRPROC  p_eglDestroyImageKHR  = nullptr;
static PFNEGLCREATEIMAGEPROC      p_eglCreateImage      = nullptr;
static PFNEGLDESTROYIMAGEPROC     p_eglDestroyImage     = nullptr;

struct OutputCtx {
  // Wayland output + per-frame state
  wl_output*   wlo         = nullptr;
  int          width       = 0;
  int          height      = 0;
  uint32_t     fourcc      = DRM_FORMAT_XRGB8888;
  bool         got_dmabuf_announce = false;
  bool         frame_ready = false;

  // Our dma-buf and wl_buffer wrapping it
  int          dmabuf_fd   = -1;
  uint32_t     stride      = 0;
  uint32_t     offset      = 0;
  wl_buffer*   wlbuf       = nullptr;

  // GL/EGL resources
  EGLImageKHR  egl_img     = EGL_NO_IMAGE_KHR;
  GLuint       texture     = 0;

  // Placement (no xdg-output; we synthesize a layout)
  int          x = 0;
  int          y = 0;
};

struct MultiCtx {
  // Wayland core
  wl_display*  display  = nullptr;
  wl_registry* registry = nullptr;

  // Protocols
  zwlr_screencopy_manager_v1* screencopy   = nullptr;
  zwp_linux_dmabuf_v1*        linux_dmabuf = nullptr;

  // DRM/GBM shared
  int         drm_fd = -1;
  gbm_device* gbm    = nullptr;

  // EGL
  EGLDisplay  egl_dpy = EGL_NO_DISPLAY;

  // Outputs we found
  std::vector<OutputCtx*> outs;
} static M;

// --------- Logging (optional) ----------
static void wl_log_handler_client(const char* fmt, va_list args) {
  vfprintf(stderr, fmt, args);
}

// --------- Helpers ----------
static void ensure_gl_egl_image_fn() {
  if (!glEGLImageTargetTexture2DOES_) {
    glEGLImageTargetTexture2DOES_ =
      (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)eglGetProcAddress("glEGLImageTargetTexture2DOES");
    if (!glEGLImageTargetTexture2DOES_)
      throw std::runtime_error("Missing GL_OES_EGL_image function glEGLImageTargetTexture2DOES");
  }
}
static void ensure_egl_image_fns() {
  if (!p_eglCreateImageKHR)  p_eglCreateImageKHR  = (PFNEGLCREATEIMAGEKHRPROC)  eglGetProcAddress("eglCreateImageKHR");
  if (!p_eglDestroyImageKHR) p_eglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC) eglGetProcAddress("eglDestroyImageKHR");
  if (!p_eglCreateImage)     p_eglCreateImage     = (PFNEGLCREATEIMAGEPROC)     eglGetProcAddress("eglCreateImage");
  if (!p_eglDestroyImage)    p_eglDestroyImage    = (PFNEGLDESTROYIMAGEPROC)    eglGetProcAddress("eglDestroyImage");
  if (!p_eglCreateImageKHR && !p_eglCreateImage)
    throw std::runtime_error("No eglCreateImage(KHR) function available from EGL");
}
static int open_render_node() {
  const char* cands[] = {
    "/dev/dri/renderD128", "/dev/dri/renderD129", "/dev/dri/renderD130"
  };
  for (const char* p : cands) {
    int fd = open(p, O_RDWR | O_CLOEXEC);
    if (fd >= 0) return fd;
  }
  throw std::runtime_error("Failed to open DRM render node (/dev/dri/renderD12x)");
}

// --------- Wayland registry ----------
static void reg_global(void*, wl_registry* reg, uint32_t name, const char* iface, uint32_t ver) {
  if (strcmp(iface, wl_output_interface.name) == 0) {
    uint32_t v = ver >= 4 ? 4 : ver;
    wl_output* out = (wl_output*)wl_registry_bind(reg, name, &wl_output_interface, v);
    auto* ctx = new OutputCtx();
    ctx->wlo = out;
    M.outs.push_back(ctx);
  } else if (strcmp(iface, zwlr_screencopy_manager_v1_interface.name) == 0) {
    uint32_t v = ver >= 3 ? 3 : ver;
    M.screencopy = (zwlr_screencopy_manager_v1*)
      wl_registry_bind(reg, name, &zwlr_screencopy_manager_v1_interface, v);
  } else if (strcmp(iface, zwp_linux_dmabuf_v1_interface.name) == 0) {
    uint32_t v = ver >= 4 ? 4 : ver;
    M.linux_dmabuf = (zwp_linux_dmabuf_v1*)
      wl_registry_bind(reg, name, &zwp_linux_dmabuf_v1_interface, v);
  }
}
static void reg_remove(void*, wl_registry*, uint32_t) {}
static const wl_registry_listener REG_LST = { reg_global, reg_remove };

// --------- Screencopy v3 listener (correct signatures) ----------
static void sc_buffer(void* data,
                      zwlr_screencopy_frame_v1*,
                      uint32_t fmt, uint32_t w, uint32_t h, uint32_t /*stride*/) {
  auto* C = static_cast<OutputCtx*>(data);
  C->fourcc = fmt;
  C->width  = (int)w;
  C->height = (int)h;
}
static void sc_flags(void*, zwlr_screencopy_frame_v1*, uint32_t /*flags*/) {}
static void sc_ready(void* data,
                     zwlr_screencopy_frame_v1*,
                     uint32_t /*tv_sec_hi*/, uint32_t /*tv_sec_lo*/, uint32_t /*tv_nsec*/) {
  auto* C = static_cast<OutputCtx*>(data);
  C->frame_ready = true;
}
static void sc_failed(void* data, zwlr_screencopy_frame_v1*) {
  auto* C = static_cast<OutputCtx*>(data);
  (void)C;
  // We treat as non-fatal for one output; you can throw if you prefer
  fprintf(stderr, "screencopy frame_failed on one output\n");
}
static void sc_damage(void*, zwlr_screencopy_frame_v1*, uint32_t, uint32_t, uint32_t, uint32_t) {}
static void sc_linux_dmabuf(void* data,
                            zwlr_screencopy_frame_v1*,
                            uint32_t fmt, uint32_t w, uint32_t h) {
  auto* C = static_cast<OutputCtx*>(data);
  C->fourcc = fmt;
  C->width  = (int)w;
  C->height = (int)h;
  C->got_dmabuf_announce = true;
}
static void sc_buffer_done(void*, zwlr_screencopy_frame_v1*) {}

static const zwlr_screencopy_frame_v1_listener FRAME_LST = {
  /* .buffer       = */ sc_buffer,
  /* .flags        = */ sc_flags,
  /* .ready        = */ sc_ready,
  /* .failed       = */ sc_failed,
  /* .damage       = */ sc_damage,
  /* .linux_dmabuf = */ sc_linux_dmabuf,
  /* .buffer_done  = */ sc_buffer_done
};

// --------- Allocate per-output GBM + wl_buffer ----------
static void alloc_dmabuf_and_wlbuf(OutputCtx* C) {
  if (M.drm_fd < 0) M.drm_fd = open_render_node();
  if (!M.gbm) {
    M.gbm = gbm_create_device(M.drm_fd);
    if (!M.gbm) throw std::runtime_error("gbm_create_device failed");
  }

  const uint32_t fmt = C->fourcc ? C->fourcc : DRM_FORMAT_XRGB8888;
  gbm_bo* bo = gbm_bo_create(M.gbm, C->width, C->height, fmt,
                             GBM_BO_USE_LINEAR | GBM_BO_USE_RENDERING);
  if (!bo) throw std::runtime_error("gbm_bo_create failed");

  C->dmabuf_fd = gbm_bo_get_fd(bo);
  C->stride    = gbm_bo_get_stride(bo);
  C->offset    = 0;
  gbm_bo_destroy(bo); // fd/stride are duplicated out; we don't keep the bo.

  if (C->dmabuf_fd < 0) throw std::runtime_error("gbm_bo_get_fd failed");
  if (!M.linux_dmabuf)  throw std::runtime_error("zwp_linux_dmabuf_v1 not bound");

  zwp_linux_buffer_params_v1* params = zwp_linux_dmabuf_v1_create_params(M.linux_dmabuf);
  if (!params) throw std::runtime_error("zwp_linux_dmabuf_v1_create_params failed");

  // plane 0 linear (modifier 0/0)
  zwp_linux_buffer_params_v1_add(params, C->dmabuf_fd, 0, C->offset, C->stride, 0, 0);

  C->wlbuf = zwp_linux_buffer_params_v1_create_immed(params, C->width, C->height, fmt, 0);
  zwp_linux_buffer_params_v1_destroy(params);

  if (!C->wlbuf) throw std::runtime_error("zwp_linux_buffer_params_v1_create_immed returned null wl_buffer");
}

// --------- Create EGLImage+GL texture from dma-buf for an output ----------
static void ensure_tex(OutputCtx* C) {
  if (!C->texture) glGenTextures(1, &C->texture);
  if (C->egl_img == EGL_NO_IMAGE_KHR) {
    if (M.egl_dpy == EGL_NO_DISPLAY) {
      M.egl_dpy = eglGetCurrentDisplay();
      if (M.egl_dpy == EGL_NO_DISPLAY) throw std::runtime_error("No current EGLDisplay");
    }
    ensure_gl_egl_image_fn();
    ensure_egl_image_fns();

    EGLImageKHR img = EGL_NO_IMAGE_KHR;

    if (!img && p_eglCreateImageKHR) {
      const EGLint attrsKHR[] = {
        EGL_LINUX_DRM_FOURCC_EXT,      (EGLint)C->fourcc,
        EGL_DMA_BUF_PLANE0_FD_EXT,     (EGLint)C->dmabuf_fd,
        EGL_DMA_BUF_PLANE0_OFFSET_EXT, (EGLint)C->offset,
        EGL_DMA_BUF_PLANE0_PITCH_EXT,  (EGLint)C->stride,
        EGL_WIDTH,                     (EGLint)C->width,
        EGL_HEIGHT,                    (EGLint)C->height,
        EGL_NONE
      };
      img = p_eglCreateImageKHR(M.egl_dpy, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT,
                                (EGLClientBuffer)nullptr, attrsKHR);
    }
#if defined(EGL_VERSION_1_5)
    if (!img && p_eglCreateImage) {
      const EGLAttrib attrsCore[] = {
        EGL_LINUX_DRM_FOURCC_EXT,      (EGLAttrib)C->fourcc,
        EGL_DMA_BUF_PLANE0_FD_EXT,     (EGLAttrib)C->dmabuf_fd,
        EGL_DMA_BUF_PLANE0_OFFSET_EXT, (EGLAttrib)C->offset,
        EGL_DMA_BUF_PLANE0_PITCH_EXT,  (EGLAttrib)C->stride,
        EGL_WIDTH,                     (EGLAttrib)C->width,
        EGL_HEIGHT,                    (EGLAttrib)C->height,
        EGL_NONE
      };
      img = p_eglCreateImage(M.egl_dpy, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT,
                             (EGLClientBuffer)nullptr, attrsCore);
    }
#endif
    if (img == EGL_NO_IMAGE_KHR)
      throw std::runtime_error("Failed to create EGLImage from dma-buf");

    C->egl_img = img;
  }

  glBindTexture(GL_TEXTURE_2D, C->texture);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glEGLImageTargetTexture2DOES_(GL_TEXTURE_2D, C->egl_img);
}

// --------- Public API ----------
void wlr_multi_capture_init(std::vector<CapturedOutput>& outs, int* totalW, int* totalH) {
  wl_log_set_handler_client(wl_log_handler_client);

  M.display = wl_display_connect(nullptr);
  if (!M.display) throw std::runtime_error("wl_display_connect failed");

  M.registry = wl_display_get_registry(M.display);
  wl_registry_add_listener(M.registry, &REG_LST, nullptr);
  wl_display_roundtrip(M.display);

  if (!M.screencopy)   throw std::runtime_error("zwlr_screencopy_manager_v1 missing");
  if (!M.linux_dmabuf) throw std::runtime_error("zwp_linux_dmabuf_v1 missing");
  if (M.outs.empty())  throw std::runtime_error("no wl_output available");

  // Probe each output -> learn w/h/fourcc via v3 buffer/linux_dmabuf events
  for (auto* C : M.outs) {
    C->frame_ready = false;
    C->got_dmabuf_announce = false;
    zwlr_screencopy_frame_v1* f =
      zwlr_screencopy_manager_v1_capture_output(M.screencopy, 0, C->wlo);
    if (!f) throw std::runtime_error("capture_output returned null on probe");
    zwlr_screencopy_frame_v1_add_listener(f, &FRAME_LST, C);

    // Wait for size info (linux_dmabuf or buffer event populates width/height)
    while (!C->got_dmabuf_announce && C->width == 0 && C->height == 0) {
      if (wl_display_dispatch(M.display) < 0)
        throw std::runtime_error("dispatch failed during probe");
    }
    if (C->width <= 0 || C->height <= 0)
      throw std::runtime_error("invalid w/h from screencopy probe");

    // Prepare our dma-buf + wl_buffer
    alloc_dmabuf_and_wlbuf(C);

    // Request copy into our wl_buffer
    zwlr_screencopy_frame_v1_copy(f, C->wlbuf);

    // Wait for ready
    while (!C->frame_ready) {
      if (wl_display_dispatch(M.display) < 0)
        throw std::runtime_error("dispatch failed waiting for frame_ready");
    }
    C->frame_ready = false;
    zwlr_screencopy_frame_v1_destroy(f);

    // Create EGLImage + GL texture
    ensure_tex(C);
  }

  // Build the exported list and simple horizontal placement
  outs.clear();
  outs.reserve(M.outs.size());
  int xcursor = 0;
  int maxH = 0;
  for (auto* C : M.outs) {
    CapturedOutput co;
    co.x = xcursor;
    co.y = 0;
    co.width  = C->width;
    co.height = C->height;
    co.texture = C->texture;
    outs.push_back(co);

    xcursor += C->width;
    if (C->height > maxH) maxH = C->height;
  }
  if (totalW) *totalW = xcursor;
  if (totalH) *totalH = maxH;
}

void wlr_multi_next_frame(std::vector<CapturedOutput>& outs) {
  (void)outs; // our internal contexts already hold wl_buffer/tex

  // Kick a screencopy for each output and wait until each is ready
  for (auto* C : M.outs) {
    C->frame_ready = false;
    zwlr_screencopy_frame_v1* f =
      zwlr_screencopy_manager_v1_capture_output(M.screencopy, 0, C->wlo);
    if (!f) throw std::runtime_error("capture_output (next) returned null");
    zwlr_screencopy_frame_v1_add_listener(f, &FRAME_LST, C);
    zwlr_screencopy_frame_v1_copy(f, C->wlbuf);
  }

  // Drain events until everyone is ready
  bool anyPending = true;
  while (anyPending) {
    if (wl_display_dispatch(M.display) < 0)
      throw std::runtime_error("dispatch failed waiting for next frames");
    anyPending = false;
    for (auto* C : M.outs) if (!C->frame_ready) { anyPending = true; break; }
  }

  for (auto* C : M.outs) {
    C->frame_ready = false;
    // Rebind the texture to ensure GL sees the image (not strictly required every frame)
    ensure_tex(C);
  }
}

void wlr_multi_shutdown() {
  for (auto* C : M.outs) {
    if (C->egl_img != EGL_NO_IMAGE_KHR) {
      if (p_eglDestroyImage)     p_eglDestroyImage(M.egl_dpy, C->egl_img);
      else if (p_eglDestroyImageKHR) p_eglDestroyImageKHR(M.egl_dpy, C->egl_img);
      C->egl_img = EGL_NO_IMAGE_KHR;
    }
    if (C->texture) { glDeleteTextures(1, &C->texture); C->texture = 0; }
    if (C->wlbuf)   { wl_buffer_destroy(C->wlbuf); C->wlbuf = nullptr; }
    if (C->dmabuf_fd >= 0) { close(C->dmabuf_fd); C->dmabuf_fd = -1; }
    if (C->wlo) { wl_output_destroy(C->wlo); C->wlo = nullptr; }
    delete C;
  }
  M.outs.clear();

  if (M.linux_dmabuf) { zwp_linux_dmabuf_v1_destroy(M.linux_dmabuf); M.linux_dmabuf = nullptr; }
  if (M.screencopy)   { zwlr_screencopy_manager_v1_destroy(M.screencopy); M.screencopy = nullptr; }
  if (M.registry)     { wl_registry_destroy(M.registry); M.registry = nullptr; }
  if (M.display)      { wl_display_disconnect(M.display); M.display = nullptr; }
  if (M.gbm)          { gbm_device_destroy(M.gbm); M.gbm = nullptr; }
  if (M.drm_fd >= 0)  { close(M.drm_fd); M.drm_fd = -1; }
}

