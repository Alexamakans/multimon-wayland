#include "capture_wlr_dmabuf.hpp"

#include <wayland-client.h>
#include <EGL/egl.h>
#include <EGL/eglext.h>
#include <GL/gl.h>

#include <fcntl.h>
#include <unistd.h>
#include <gbm.h>
#include <xf86drm.h>
#include <drm_fourcc.h>

#include <stdexcept>
#include <cstring>
#include <cstdio>

// Generated by wayland-scanner
#include "wlr-screencopy-unstable-v1-client-protocol.h"
#include "linux-dmabuf-unstable-v1-client-protocol.h"

// ---------- GL/EGL extension pointers ----------
static PFNGLEGLIMAGETARGETTEXTURE2DOESPROC glEGLImageTargetTexture2DOES_ = nullptr;

// Use function pointers for EGL image create/destroy to avoid link-time refs.
static PFNEGLCREATEIMAGEKHRPROC   p_eglCreateImageKHR   = nullptr; // KHR path (EGLint attrs)
static PFNEGLDESTROYIMAGEKHRPROC  p_eglDestroyImageKHR  = nullptr;
static PFNEGLCREATEIMAGEPROC      p_eglCreateImage      = nullptr; // EGL 1.5 path (EGLAttrib attrs)
static PFNEGLDESTROYIMAGEPROC     p_eglDestroyImage     = nullptr;

struct WLCtx {
  // Wayland core
  wl_display*  display  = nullptr;
  wl_registry* registry = nullptr;
  wl_output*   output   = nullptr;

  // Protocols we use
  zwlr_screencopy_manager_v1* screencopy  = nullptr;
  zwp_linux_dmabuf_v1*        linux_dmabuf = nullptr;

  // DRM/GBM
  int         drm_fd = -1;
  gbm_device* gbm    = nullptr;
  gbm_bo*     bo     = nullptr;

  // Format & geometry
  int       width  = 0;
  int       height = 0;
  uint32_t  fourcc = DRM_FORMAT_XRGB8888;
  uint64_t  modifier = DRM_FORMAT_MOD_INVALID;

  // Single-plane (linear) info
  int       fds[4]     = { -1,-1,-1,-1 };
  uint32_t  strides[4] = { 0,0,0,0 };
  uint32_t  offsets[4] = { 0,0,0,0 };
  int       nplanes    = 1;

  // Wayland buffer wrapping our dmabuf
  wl_buffer*  wlbuf   = nullptr;

  // EGL/GL
  EGLDisplay  egl_dpy = EGL_NO_DISPLAY;
  EGLImageKHR egl_img = EGL_NO_IMAGE_KHR;
  GLuint      tex     = 0;

  // State flags
  bool got_linux_dmabuf_announce = false;
  bool frame_ready = false;
} static G;

// ---------- logging ----------
static void wl_log_handler_client(const char* fmt, va_list args) {
  vfprintf(stderr, fmt, args);
}

// ---------- helpers ----------
static void ensure_gl_egl_image_fn() {
  if (!glEGLImageTargetTexture2DOES_) {
    glEGLImageTargetTexture2DOES_ =
      (PFNGLEGLIMAGETARGETTEXTURE2DOESPROC)eglGetProcAddress("glEGLImageTargetTexture2DOES");
    if (!glEGLImageTargetTexture2DOES_)
      throw std::runtime_error("GL_OES_EGL_image not available (glEGLImageTargetTexture2DOES missing)");
  }
}

static void ensure_egl_image_fns() {
  // Try both KHR and core 1.5; call via whichever we get.
  if (!p_eglCreateImageKHR)  p_eglCreateImageKHR  = (PFNEGLCREATEIMAGEKHRPROC)  eglGetProcAddress("eglCreateImageKHR");
  if (!p_eglDestroyImageKHR) p_eglDestroyImageKHR = (PFNEGLDESTROYIMAGEKHRPROC) eglGetProcAddress("eglDestroyImageKHR");
  if (!p_eglCreateImage)     p_eglCreateImage     = (PFNEGLCREATEIMAGEPROC)     eglGetProcAddress("eglCreateImage");
  if (!p_eglDestroyImage)    p_eglDestroyImage    = (PFNEGLDESTROYIMAGEPROC)    eglGetProcAddress("eglDestroyImage");
  if (!p_eglCreateImageKHR && !p_eglCreateImage)
    throw std::runtime_error("No eglCreateImage(KHR) function available from EGL");
}

static int open_render_node() {
  const char* cands[] = {
    "/dev/dri/renderD128", "/dev/dri/renderD129", "/dev/dri/renderD130"
  };
  for (const char* p : cands) {
    int fd = open(p, O_RDWR | O_CLOEXEC);
    if (fd >= 0) return fd;
  }
  throw std::runtime_error("Failed to open DRM render node (/dev/dri/renderD12x)");
}

// ---------- registry ----------
static void reg_global(void*, wl_registry* reg, uint32_t name, const char* iface, uint32_t ver) {
  if (strcmp(iface, wl_output_interface.name) == 0) {
    if (!G.output) {
      uint32_t v = ver >= 4 ? 4 : ver;
      G.output = (wl_output*)wl_registry_bind(reg, name, &wl_output_interface, v);
    }
  } else if (strcmp(iface, zwlr_screencopy_manager_v1_interface.name) == 0) {
    uint32_t v = ver >= 3 ? 3 : ver; // want v3 semantics
    G.screencopy = (zwlr_screencopy_manager_v1*)
      wl_registry_bind(reg, name, &zwlr_screencopy_manager_v1_interface, v);
  } else if (strcmp(iface, zwp_linux_dmabuf_v1_interface.name) == 0) {
    uint32_t v = ver >= 4 ? 4 : ver;
    G.linux_dmabuf = (zwp_linux_dmabuf_v1*)
      wl_registry_bind(reg, name, &zwp_linux_dmabuf_v1_interface, v);
  }
}
static void reg_remove(void*, wl_registry*, uint32_t) {}
static const wl_registry_listener REG_LST = { reg_global, reg_remove };

// ---------- screencopy v3 listener ----------
static void sc_buffer(void*, zwlr_screencopy_frame_v1*, uint32_t fmt, uint32_t w, uint32_t h, uint32_t /*stride*/) {
  G.fourcc = fmt; G.width = (int)w; G.height = (int)h;
}
static void sc_flags(void*, zwlr_screencopy_frame_v1*, uint32_t /*flags*/) {}
static void sc_ready(void*, zwlr_screencopy_frame_v1*, uint32_t /*tv_sec_hi*/, uint32_t /*tv_sec_lo*/, uint32_t /*tv_nsec*/) {
  G.frame_ready = true;
}
static void sc_failed(void*, zwlr_screencopy_frame_v1*) {
  throw std::runtime_error("screencopy frame_failed");
}
static void sc_damage(void*, zwlr_screencopy_frame_v1*, uint32_t /*x*/, uint32_t /*y*/, uint32_t /*w*/, uint32_t /*h*/) {}
static void sc_linux_dmabuf(void*, zwlr_screencopy_frame_v1*, uint32_t fmt, uint32_t w, uint32_t h) {
  G.fourcc = fmt; G.width = (int)w; G.height = (int)h; G.got_linux_dmabuf_announce = true;
}
static void sc_buffer_done(void*, zwlr_screencopy_frame_v1*) {}

static const zwlr_screencopy_frame_v1_listener FRAME_LST = {
  /* .buffer       = */ sc_buffer,
  /* .flags        = */ sc_flags,
  /* .ready        = */ sc_ready,
  /* .failed       = */ sc_failed,
  /* .damage       = */ sc_damage,
  /* .linux_dmabuf = */ sc_linux_dmabuf,
  /* .buffer_done  = */ sc_buffer_done
};

// ---------- allocate our dmabuf + wl_buffer ----------
static void create_gbm_and_wlbuffer() {
  if (G.drm_fd < 0) G.drm_fd = open_render_node();
  if (!G.gbm) {
    G.gbm = gbm_create_device(G.drm_fd);
    if (!G.gbm) throw std::runtime_error("gbm_create_device failed");
  }
  const uint32_t fmt = G.fourcc ? G.fourcc : DRM_FORMAT_XRGB8888;

  G.bo = gbm_bo_create(G.gbm, G.width, G.height, fmt,
                       GBM_BO_USE_LINEAR | GBM_BO_USE_RENDERING);
  if (!G.bo) throw std::runtime_error("gbm_bo_create failed");

  G.nplanes    = 1;
  G.fds[0]     = gbm_bo_get_fd(G.bo);
  G.strides[0] = gbm_bo_get_stride(G.bo);
  G.offsets[0] = 0;
  if (G.fds[0] < 0) throw std::runtime_error("gbm_bo_get_fd failed");

  if (!G.linux_dmabuf) throw std::runtime_error("zwp_linux_dmabuf_v1 not bound");

  zwp_linux_buffer_params_v1* params = zwp_linux_dmabuf_v1_create_params(G.linux_dmabuf);
  if (!params) throw std::runtime_error("zwp_linux_dmabuf_v1_create_params failed");

  // plane 0, linear (modifier 0/0)
  zwp_linux_buffer_params_v1_add(params, G.fds[0], 0, G.offsets[0], G.strides[0], 0, 0);

  G.wlbuf = zwp_linux_buffer_params_v1_create_immed(params, G.width, G.height, fmt, 0);
  zwp_linux_buffer_params_v1_destroy(params);

  if (!G.wlbuf) throw std::runtime_error("zwp_linux_buffer_params_v1_create_immed returned null wl_buffer");
}

// ---------- create GL texture from EGLImage ----------
static void ensure_egl_image_and_texture() {
  if (G.tex == 0) glGenTextures(1, &G.tex);

  if (G.egl_img == EGL_NO_IMAGE_KHR) {
    G.egl_dpy = eglGetCurrentDisplay();
    if (G.egl_dpy == EGL_NO_DISPLAY) throw std::runtime_error("No current EGLDisplay");
    ensure_gl_egl_image_fn();
    ensure_egl_image_fns();

    EGLImageKHR img = EGL_NO_IMAGE_KHR;

    // Try KHR first (EGLint* attrs)
    if (!img && p_eglCreateImageKHR) {
      const EGLint attrsKHR[] = {
        EGL_LINUX_DRM_FOURCC_EXT,       (EGLint)G.fourcc,
        EGL_DMA_BUF_PLANE0_FD_EXT,      (EGLint)G.fds[0],
        EGL_DMA_BUF_PLANE0_OFFSET_EXT,  (EGLint)G.offsets[0],
        EGL_DMA_BUF_PLANE0_PITCH_EXT,   (EGLint)G.strides[0],
        EGL_WIDTH,                      (EGLint)G.width,
        EGL_HEIGHT,                     (EGLint)G.height,
        EGL_NONE
      };
      img = p_eglCreateImageKHR(G.egl_dpy, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT,
                                (EGLClientBuffer)nullptr, attrsKHR);
    }

#if defined(EGL_VERSION_1_5)
    // Fallback to core 1.5 (EGLAttrib* attrs) if available
    if (!img && p_eglCreateImage) {
      const EGLAttrib attrsCore[] = {
        EGL_LINUX_DRM_FOURCC_EXT,       (EGLAttrib)G.fourcc,
        EGL_DMA_BUF_PLANE0_FD_EXT,      (EGLAttrib)G.fds[0],
        EGL_DMA_BUF_PLANE0_OFFSET_EXT,  (EGLAttrib)G.offsets[0],
        EGL_DMA_BUF_PLANE0_PITCH_EXT,   (EGLAttrib)G.strides[0],
        EGL_WIDTH,                      (EGLAttrib)G.width,
        EGL_HEIGHT,                     (EGLAttrib)G.height,
        EGL_NONE
      };
      img = p_eglCreateImage(G.egl_dpy, EGL_NO_CONTEXT, EGL_LINUX_DMA_BUF_EXT,
                             (EGLClientBuffer)nullptr, attrsCore);
    }
#endif

    if (img == EGL_NO_IMAGE_KHR)
      throw std::runtime_error("Failed to create EGLImage from dma-buf");

    G.egl_img = img;
  }

  glBindTexture(GL_TEXTURE_2D, G.tex);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
  glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
  glEGLImageTargetTexture2DOES_(GL_TEXTURE_2D, G.egl_img);
}

// ---------- public API ----------
void wlr_dmabuf_capture_init(const char* /*outputNameOptional*/, int* outW, int* outH) {
  wl_log_set_handler_client(wl_log_handler_client);

  G.display = wl_display_connect(nullptr);
  if (!G.display) throw std::runtime_error("wl_display_connect failed");

  G.registry = wl_display_get_registry(G.display);
  wl_registry_add_listener(G.registry, &REG_LST, nullptr);
  wl_display_roundtrip(G.display);

  if (!G.screencopy)   throw std::runtime_error("zwlr_screencopy_manager_v1 missing");
  if (!G.linux_dmabuf) throw std::runtime_error("zwp_linux_dmabuf_v1 missing");
  if (!G.output)       throw std::runtime_error("no wl_output available");

  // Probe one frame to learn size/format
  zwlr_screencopy_frame_v1* f =
      zwlr_screencopy_manager_v1_capture_output(G.screencopy, 0, G.output);
  if (!f) throw std::runtime_error("capture_output returned null");

  zwlr_screencopy_frame_v1_add_listener(f, &FRAME_LST, nullptr);

  while (!G.got_linux_dmabuf_announce && G.width == 0 && G.height == 0) {
    if (wl_display_dispatch(G.display) < 0)
      throw std::runtime_error("dispatch failed during probe");
  }
  if (G.width <= 0 || G.height <= 0)
    throw std::runtime_error("invalid w/h learned from screencopy probe");

  // allocate our dmabuf + wl_buffer
  create_gbm_and_wlbuffer();

  // request copy into our wl_buffer
  zwlr_screencopy_frame_v1_copy(f, G.wlbuf);

  while (!G.frame_ready) {
    if (wl_display_dispatch(G.display) < 0)
      throw std::runtime_error("dispatch failed waiting for frame_ready");
  }
  G.frame_ready = false;
  zwlr_screencopy_frame_v1_destroy(f);

  // turn dmabuf into GL texture
  ensure_egl_image_and_texture();

  if (outW) *outW = G.width;
  if (outH) *outH = G.height;
}

CaptureFrame wlr_dmabuf_next_frame() {
  zwlr_screencopy_frame_v1* f =
      zwlr_screencopy_manager_v1_capture_output(G.screencopy, 0, G.output);
  if (!f) throw std::runtime_error("capture_output (next) returned null");

  zwlr_screencopy_frame_v1_add_listener(f, &FRAME_LST, nullptr);
  zwlr_screencopy_frame_v1_copy(f, G.wlbuf);

  while (!G.frame_ready) {
    if (wl_display_dispatch(G.display) < 0)
      throw std::runtime_error("dispatch failed waiting for next frame_ready");
  }
  G.frame_ready = false;
  zwlr_screencopy_frame_v1_destroy(f);

  glBindTexture(GL_TEXTURE_2D, G.tex);

  CaptureFrame cf;
  cf.texture = G.tex;
  cf.width   = G.width;
  cf.height  = G.height;
  return cf;
}

void wlr_dmabuf_capture_shutdown() {
  if (G.egl_img != EGL_NO_IMAGE_KHR) {
    if (p_eglDestroyImage)     p_eglDestroyImage(G.egl_dpy, G.egl_img);
    else if (p_eglDestroyImageKHR) p_eglDestroyImageKHR(G.egl_dpy, G.egl_img);
    G.egl_img = EGL_NO_IMAGE_KHR;
  }
  if (G.tex)     { glDeleteTextures(1, &G.tex); G.tex = 0; }
  if (G.wlbuf)   { wl_buffer_destroy(G.wlbuf); G.wlbuf = nullptr; }
  for (int i=0;i<4;++i) if (G.fds[i] >= 0) { close(G.fds[i]); G.fds[i] = -1; }
  if (G.bo)      { gbm_bo_destroy(G.bo); G.bo = nullptr; }
  if (G.gbm)     { gbm_device_destroy(G.gbm); G.gbm = nullptr; }
  if (G.output)  { wl_output_destroy(G.output); G.output = nullptr; }
  if (G.linux_dmabuf) { zwp_linux_dmabuf_v1_destroy(G.linux_dmabuf); G.linux_dmabuf = nullptr; }
  if (G.screencopy)   { zwlr_screencopy_manager_v1_destroy(G.screencopy); G.screencopy = nullptr; }
  if (G.registry){ wl_registry_destroy(G.registry); G.registry = nullptr; }
  if (G.display) { wl_display_disconnect(G.display); G.display = nullptr; }
  if (G.drm_fd >= 0) { close(G.drm_fd); G.drm_fd = -1; }
}

